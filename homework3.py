# -*- coding: utf-8 -*-
"""Homework3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aQBwEt0pyLM9PeLoMes755NqoUA7Z5_u

# Importing modules and mounting google
"""

import os, sys
from google.colab import drive
drivedir = '/content/drive'
drive.mount(drivedir)
os.chdir(drivedir)

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# # install required modules I
# !apt-get install libproj-dev proj-data proj-bin
# !apt-get install libgeos-dev
# !pip install cython
# !pip install cartopy

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# # install required modules II
# !apt-get -qq install python-cartopy python3-cartopy
# !pip uninstall -y shapely
# !pip install shapely --no-binary shapely

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.dates import DateFormatter
import xarray as xr
import pandas as pd
from scipy import signal
import cartopy
from cartopy.util import add_cyclic_point
import cartopy.crs as ccrs

"""# PART A: Power Spectrum Analysis

## Identify fourier components in a time series
"""

datadir = drivedir+'/MyDrive/UNI_UNIBO/Topic3'
y = np.load(datadir+'/timeseries.npy')
t = np.load(datadir+'/timeseries_time.npy')

fig, ax = plt.subplots(nrows=1, ncols=1,figsize=(12,6))
ax.set(xlabel='time [years]', ylabel="T [°C]", title='Timeseries')
ax.plot(t,y)
ax.grid()

L = len(y)  #length of the signal in months
Lyr = L/12; #length of the signal in years

# Compute Power Spectra
LPS = int((L/2))
prds_yrs = Lyr/np.arange(1,LPS)
sfft_all = np.fft.fft(y)
sfft = sfft_all[1:LPS]

# Normalize to get the actual signal amplitude
sfft_amp = 2*sfft/L

fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(20,12), constrained_layout = True)
ax.plot(prds_yrs,np.abs(sfft_amp))
ax.title.set_text('s_fft norm. to get amplitudes [units]')
ax.set_ylabel('[units]')
ax.set_xlabel('time in years')
ax.grid()

"""OBSERVATIONS: Many different frequencies of oscillations are visible. The highest frequency oscillation is the seasonal cycle, with a periodicity of one year, and an amplitude of about 5 °C. This is modulated by another oscillation, with a periodicity of 6 years and an amplitude of about 2.5 °C. This could be the manifestation of El Nino, which has in fact a periodicity of 6-7 years. Finally, there is a broader oscillation, with a periodicity of about 30-35 years, and an amplitude of about 1°C. This could be due to the Pacific Decadal Oscillation, which has a periodicity of 20-30 years.

## Compare Investigate SST variability: Equatorial Eastern Pacific vs North Pacific
"""

ds = xr.open_mfdataset(datadir+'/ERA5_sst_1958_2022_newg.nc')
ds['sst'] = ds['sst']-273.15
ds['sst'] = ds.sst.assign_attrs(units='°C')
lon_shift = -360

ds_mclm = ds.groupby('time.month').mean('time') #Monthly mean climatology
ds_mano = ds.groupby('time.month') - ds_mclm #Monthly mean anomaly
ds_stdv= ds.groupby('time.month').std(dim='time') #STD
ds_std_mano = ds_mano.std(dim='time') #STD of the monthly mean anomaly

EEPi = ds_mano.sst.sel(lat=slice(-6, 6), lon=slice(-170,120)).mean(dim=('lat',
'lon')).compute()-273.15
NPi = ds_mano.sst.sel(lat=slice(35, 45), lon=slice(-190,-140)).mean(dim=('lat',
'lon')).compute()-273.15

L = len(EEPi) #length of the signal in months
Lyr = L/12  #length of the signal in years

# Compute Power Spectra
LPS = int((L/2))
prds_yrs = Lyr/np.arange(1,LPS)

sfft_all1 = np.fft.fft(EEPi)
sfft1 = sfft_all1[1:LPS]
sfft_all2 = np.fft.fft(NPi)
sfft2 = sfft_all2[1:LPS]

# Normalize to get the actual signal amplitude
sfft_amp1 = 2*sfft1/L
sfft_amp2 = 2*sfft2/L

fig, ax = plt.subplots(nrows=2, ncols=1,figsize=(15,6), sharex=True)
ax[0].plot(prds_yrs,np.abs(sfft_amp1), label='Eastern Equatorial Pacific')
ax[0].plot(prds_yrs,np.abs(sfft_amp2), label='North Pacific')
ax[0].title.set_text('s_fft norm. to get amplitudes [units]')
ax[0].set_ylabel('[units]')
ax[0].legend()
ax[0].grid()

#Doing a moving average
df_EEPi = pd.DataFrame(np.abs(sfft_amp1))
df_NPi = pd.DataFrame(np.abs(sfft_amp2))
EEPi_mavg = df_EEPi.rolling(7, center=True).mean()
NPi_mavg = df_NPi.rolling(7, center=True).mean()

ax[1].plot(prds_yrs,EEPi_mavg)
ax[1].plot(prds_yrs,NPi_mavg)
ax[1].title.set_text('s_fft norm. to get amplitudes [units] with moving average')
ax[1].set_ylabel('[units]')
ax[1].set_xlabel('time in years')
ax[1].grid()

# Normalize to get the units of variance
sfft_var1 = 2*(sfft1/L)**2
sfft_totvar1 = np.sum(np.abs((sfft_var1)))
sfft_var2 = 2*(sfft2/L)**2
sfft_totvar2 = np.sum(np.abs((sfft_var2)))

fig, ax = plt.subplots(nrows=2, ncols=1,figsize=(15,6), sharex=True)
ax[0].plot(prds_yrs,np.abs(sfft_var1), label='EEPi,Signal total variance: ' +
           str(sfft_totvar1.round(2))+' [units^2]')
ax[0].plot(prds_yrs,np.abs(sfft_var2),label='NPi, Signal total variance: ' +
           str(sfft_totvar2.round(2))+' [units^2]')
ax[0].title.set_text('s_fft norm. to get variances')
ax[0].set_ylabel('[units^2]')
ax[0].set_xlabel('time in years')
ax[0].legend()
ax[0].grid()


#moving average
df_psp1 = pd.DataFrame(np.abs(sfft_var1))
df_psp2 = pd.DataFrame(np.abs(sfft_var2))
psp_mavg_EEPi = df_psp1.rolling(7, center=True).mean()
psp_mavg_NPi=df_psp2.rolling(7, center=True).mean()

ax[1].plot(prds_yrs,psp_mavg_EEPi)
ax[1].plot(prds_yrs,psp_mavg_NPi)
ax[1].title.set_text('s_fft norm. to get variances with moving average')
ax[1].set_ylabel('[units^2]')
ax[1].set_xlabel('time in years')
ax[1].grid()

"""OBSERVATIONS: the moving average is used to smooth out short-term fluctuations and highlight longer-term trends. \\
In the Eastern Equatorial Pacific, the spectrum with the rolling average shows the highest peak in a cycle with a periodicity of ~5 years, which could be connected with El Nino, that acts directly on the equatorial Pacific. \\
The North Pacific spectrum shows a peak in a cycle with a periodicity of ~7 years, but is in general more distributed, with high values having periodicities between 7 and 13 years. This indicates that the source of anomaly in this case is not mainly El Nino, but also other factors are contributing

# PART B: EOF Analysis
"""

fig, ax = plt.subplots(nrows=3, ncols=1, figsize=(15,18))

#LONG TERM AVERAGE
ax1 = plt.subplot(3, 1, 1)
ds_mclm.sst[-1,:,:].plot.pcolormesh(ax=ax1,vmin=-5, vmax=35, cmap='coolwarm')
ax1.set(title='SST mean (long-term average)')

#STD
ax2 = plt.subplot(3, 1, 2)
ds_stdv.sst[-1,:,:].plot.pcolormesh(ax=ax2, vmin=0, vmax=3, cmap='coolwarm')
ax2.set(title=' SST STD (long-term standard deviation)')

#STANDARD DEVIATION OF THE MONTHLY MEAN ANOMALY
ax3 = plt.subplot(3, 1, 3)
ds_std_mano.sst[:,:].plot.pcolormesh(ax=ax3, vmin=0, vmax=2, cmap='coolwarm')
ax3.set(title='Standard deviation of monthly mean SST anomaly')

"""OBSERVATIONS: in the first graph we can see the typical zonal pattern that the SST has: warmer temperatures at the equator, due to higher insolation, and lower temperatures at the poles. \\
The second graph highlights the places with higher oscillations of temperature considering the climatology. Higher values of STD are visible in some zones, such as the equatorial eastern pacific (due to El Nino oscillation) and around some coasts(coastal areas usually have higher temperature oscillation than open-sea areas) and in closed basins. As one would expect, the zones of high STD correspond with the places in graph 1 where the SST was higher or lower than their surrounding values. This is because, since those points are points of SST oscillations, their climatology will not follow the typical trend of that area, hence they are anomalies. \\
The third graph shows the areas where the monthly mean anomalies oscillate the most. Here we can find places like the eastern equatorial Pacific (due to El Nino), the North Pacific (probably due to the Pacific Decadal Oscillation) and the north Atlantic (probably due to the North Atlantic Oscillations). Those are all places where not only we have periods of anomalous SST (which is, a SST that is fairly different from the climatology), but that this anomaly itself has a larger oscillation than the normal seasonal cycle.

## Decompose SST variability in modes using the EOF analysis
"""

#RAW DATA EOF AND PC

#Prepare empty arrays
SST_raw = ds.sst.values
SST_raw = np.moveaxis(SST_raw, [0, 2], [2, 0]) #Permute dimensions 0 and 2.
I,J,T = SST_raw.shape #Get dataset dimensions
eofs_raw = np.empty((J,I,T))
pcs_raw = np.empty((T,T))

norm_cos_lat = 1
if norm_cos_lat: #points at the equator have different weights than at the poles
  [LON,LAT] = np.meshgrid(ds.lon,ds.lat)
  Wyx = np.cos(np.deg2rad(LAT))
  Wxy = np.moveaxis(Wyx, [0, 1], [1, 0])
  Wxyt = np.tile(Wxy[:,:,np.newaxis], [1,1,T])
  dnew = (Wxyt*SST_raw).reshape((I*J,T))
else:
  dnew = SST_raw.reshape(I*J,T)


#Select only ocean points (SST is not defined over land)
inan = np.argwhere(~np.isnan(dnew[:,1]))[:,0] #Find sea points
dnew = dnew[inan,:] #Select only sea points
#Compute covariance-like matrix (not scaled!)
dd = np.matmul(dnew.T,dnew)
# Extract eigenvectors and eigenvalues
[lambdas,A] = np.linalg.eig(dd)

E = np.matmul(dnew,A)#Project data onto eigenvectors
varexp_raw = 100*lambdas/lambdas.sum() #Compute explained variance

# renormalize to obtain PCs in STD units and EOFs in regression units [°C/std]
nmodes = T
for i in range(T):
 m1 = np.empty((I*J))*np.nan
 m1[inan] = E[:,i]
 mstd = np.std(A[:,i])
 eofs_raw[:,:,i] = m1.reshape(I,J).T*mstd
 pcs_raw[:,i] = A[:,i]/mstd

fig = plt.figure(figsize=(18,6))
gs = fig.add_gridspec(3, 2)

for i in range(3):
  # Select the week 1 forecast from the specified model
  data = eofs_raw[:,:,i]
  # Add the cyclic point
  data,lons = add_cyclic_point(data,coord=ds_mano['lon'])
  ax1 = fig.add_subplot(gs[i, 0], projection=ccrs.PlateCarree())
  cs = ax1.pcolor(lons,ds_mano['lat'],data, vmin=-1.5, vmax=1.5,
                    transform = ccrs.PlateCarree(),
                    cmap='coolwarm')

  ax1.coastlines(resolution='auto', color='k')
  ax1.set_title('EOF'+str(i+1)+' [°C/std]')

  ax2 = fig.add_subplot(gs[i, 1])
  ax2.plot(ds['time'],pcs_raw[:,i])
  ax2.set_ylabel('PC'+str(i+1)+' [Norm.]')
  ax2.set_xlabel('time')

# Adjust the location of the subplots on the page to make room for the colorbar
fig.subplots_adjust(bottom=0.2, top=0.9, left=0.125, right=0.9,
                    wspace=0.02, hspace=0.25)
# Add a colorbar axis at the bottom of the graph
cbar_ax = fig.add_axes([0.2, 0.1, 0.25, 0.02])
# Draw the colorbar
cbar=fig.colorbar(cs, cax=cbar_ax,orientation='horizontal')

for i in range(3):
  print('Percentage of variance explained by mode ' + str(i+1)+ ': ' +
        str(varexp_raw[i]))

"""OBSERVATIONS: the first mode has a general warming trend, so it represents global warming. This is also very visible from the PC1, where the fact that we only have positive values means that this trend is never reversed. This has a variance of 99%, so it's the predominant pattern. \\
The second mode sees the two hemispheres anticorrelated by 0.57%, so it indicates the seasonal cycle. This is also visible from the PC2, that shows the oscillations with a periodicity of one year. \\
The third mode represents El Nino.
"""

#MONTHLY MEAN ANOMALY EOF AND PC

#Prepare empty arrays
SST_mano = ds_mano.sst.values
SST_mano = np.moveaxis(SST_mano, [0, 2], [2, 0]) #Permute dimensions 0 and 2.
I,J,T = SST_mano.shape #Get dataset dimensions
eofs_mano = np.empty((J,I,T))
pcs_mano = np.empty((T,T))

norm_cos_lat = 1
if norm_cos_lat:
  [LON,LAT] = np.meshgrid(ds.lon,ds.lat)
  Wyx = np.cos(np.deg2rad(LAT))
  Wxy = np.moveaxis(Wyx, [0, 1], [1, 0])
  Wxyt = np.tile(Wxy[:,:,np.newaxis], [1,1,T])
  dnew = (Wxyt*SST_mano).reshape((I*J,T))
else:
  dnew = SST_mano.reshape(I*J,T)

#Select only ocean points (SST is not defined over land)
inan = np.argwhere(~np.isnan(dnew[:,1]))[:,0] #Find sea points
dnew = dnew[inan,:] #Select only sea points
#Compute covariance-like matrix (not scaled!)
dd = np.matmul(dnew.T,dnew)
# Extract eigenvectors and eigenvalues
[lambdas,A] = np.linalg.eig(dd)

E = np.matmul(dnew,A)#Project data onto eigenvectors
varexp_mano = 100*lambdas/lambdas.sum() #Compute explained variance

# renormalize to obtain PCs in STD units and EOFs in regression units [°C/std]
nmodes = T
for i in range(T):
 m1 = np.empty((I*J))*np.nan
 m1[inan] = E[:,i]
 mstd = np.std(A[:,i])
 eofs_mano[:,:,i] = m1.reshape(I,J).T*mstd
 pcs_mano[:,i] = A[:,i]/mstd

fig = plt.figure(figsize=(18,6))
gs = fig.add_gridspec(3, 2)

for i in range(3):
  # Select the week 1 forecast from the specified model
  data = eofs_mano[:,:,i]
  # Add the cyclic point
  data,lons = add_cyclic_point(data,coord=ds_mano['lon'])
  ax1 = fig.add_subplot(gs[i, 0], projection=ccrs.PlateCarree())
  cs = ax1.pcolor(lons,ds_mano['lat'],data, vmin=-0.4,vmax=0.4,
                    transform = ccrs.PlateCarree(),
                    cmap='coolwarm')

  ax1.coastlines(resolution='auto', color='k')
  ax1.set_title('EOF'+str(i+1)+' [°C/std]')

  ax2 = fig.add_subplot(gs[i, 1])
  ax2.plot(ds['time'],pcs_mano[:,i])
  ax2.set_ylabel('PC'+str(i+1)+' [Norm.]')
  ax2.set_xlabel('time')

# Adjust the location of the subplots on the page to make room for the colorbar
fig.subplots_adjust(bottom=0.2, top=0.9, left=0.125, right=0.9,
                    wspace=0.02, hspace=0.25)
# Add a colorbar axis at the bottom of the graph
cbar_ax = fig.add_axes([0.2, 0.1, 0.25, 0.02])
# Draw the colorbar
cbar=fig.colorbar(cs, cax=cbar_ax,orientation='horizontal')

for i in range(3):
  print('Percentage of variance explained by mode ' + str(i+1)+ ': ' + str(varexp_mano[i]))

"""OBSERVATIONS: The first mode represetnts El Nino. The variance is so low (15%) because we are considering the whole globe. If we were only to consider the Pacific Ocean, this mode would have a variance of about 44%. \\
The second mode has a lower variance, it could be related to global warming. \\
The third EOF is some pattern of oscillation with a smaller variance (4%)
"""

#DETRENDED SST EOF AND PC

#Prepare empty arrays
SST_detrend = ds.sst.values
SST_detrend = np.moveaxis(SST_detrend, [0, 2], [2, 0]) #Permute dimensions 0 and 2.
I,J,T = SST_detrend.shape #Get dataset dimensions
eofs_detrend = np.empty((J,I,T))
pcs_detrend = np.empty((T,T))

norm_cos_lat = 1
if norm_cos_lat:
  [LON,LAT] = np.meshgrid(ds.lon,ds.lat)
  Wyx = np.cos(np.deg2rad(LAT))
  Wxy = np.moveaxis(Wyx, [0, 1], [1, 0])
  Wxyt = np.tile(Wxy[:,:,np.newaxis], [1,1,T])
  dnew = (Wxyt*SST_detrend).reshape((I*J,T))
else:
  dnew = SST_detrend.reshape(I*J,T)

#Select only ocean points (SST is not defined over land)
inan = np.argwhere(~np.isnan(dnew[:,1]))[:,0] #Find sea points
dnew = dnew[inan,:] #Select only sea points
dnew=signal.detrend(dnew,1) #detrend
#Compute covariance-like matrix (not scaled!)
dd = np.matmul(dnew.T,dnew)
# Extract eigenvectors and eigenvalues
[lambdas,A] = np.linalg.eig(dd)

E = np.matmul(dnew,A)#Project data onto eigenvectors
varexp_detrend = 100*lambdas/lambdas.sum() #Compute explained variance

# renormalize to obtain PCs in STD units and EOFs in regression units [°C/std]
nmodes = T
for i in range(T):
 m1 = np.empty((I*J))*np.nan
 m1[inan] = E[:,i]
 mstd = np.std(A[:,i])
 eofs_detrend[:,:,i] = m1.reshape(I,J).T*mstd
 pcs_detrend[:,i] = A[:,i]/mstd

fig = plt.figure(figsize=(18,6))
gs = fig.add_gridspec(3, 2)

for i in range(3):
  # Select the week 1 forecast from the specified model
  data = eofs_detrend[:,:,i]
  # Add the cyclic point
  data,lons=add_cyclic_point(data,coord=ds_mano['lon'])
  ax1 = fig.add_subplot(gs[i, 0], projection=ccrs.PlateCarree())
  cs = ax1.pcolor(lons,ds_mano['lat'],data,vmin=-1,vmax=1,
                    transform = ccrs.PlateCarree(),
                    cmap='coolwarm')

  ax1.coastlines(resolution='auto', color='k')
  ax1.set_title('EOF'+str(i+1)+' [°C/std]')

  ax2 = fig.add_subplot(gs[i, 1])
  ax2.plot(ds['time'],pcs_detrend[:,i])
  ax2.set_ylabel('PC'+str(i+1)+' [Norm.]')
  ax2.set_xlabel('time')

# Adjust the location of the subplots on the page to make room for the colorbar
fig.subplots_adjust(bottom=0.2, top=0.9, left=0.125, right=0.9,
                    wspace=0.02, hspace=0.25)
# Add a colorbar axis at the bottom of the graph
cbar_ax = fig.add_axes([0.2, 0.1, 0.25, 0.02])
# Draw the colorbar
cbar=fig.colorbar(cs, cax=cbar_ax,orientation='horizontal')

for i in range(3):
  print('Percentage of variance explained by mode ' + str(i+1)+ ': ' +
        str(varexp_detrend[i]))

"""OBSERVATIONS: here with the detrended SST, we removed the first mode (global warming pattern), so the first mode now represents the seasonal cycle, and has a much higher variance than before. \\
The second mode is now El Nino. \\
The third mode is some pattern with a very high oscillation, even higher than the seasonal cycle, that show a decrease of temperature in tropical areas and an increase in higher latitudes.
"""

#DETRENDED MONTHLY MEAN SST ANOMALY EOF AND PC

#Prepare empty arrays
SST_detrend_mano = ds_mano.sst.values
SST_detrend_mano = np.moveaxis(SST_detrend_mano, [0, 2], [2, 0]) #Permute dimensions 0 and 2.
I,J,T = SST_detrend_mano.shape #Get dataset dimensions
eofs_detrend_mano = np.empty((J,I,T))
pcs_detrend_mano = np.empty((T,T))

norm_cos_lat=1
if norm_cos_lat:
  [LON,LAT] = np.meshgrid(ds.lon,ds.lat)
  Wyx = np.cos(np.deg2rad(LAT))
  Wxy = np.moveaxis(Wyx, [0, 1], [1, 0])
  Wxyt = np.tile(Wxy[:,:,np.newaxis], [1,1,T])
  dnew = (Wxyt*SST_detrend_mano).reshape((I*J,T))
else:
  dnew = SST_detrend_mano.reshape(I*J,T)

#Select only ocean points (SST is not defined over land)
inan = np.argwhere(~np.isnan(dnew[:,1]))[:,0] #Find sea points
dnew = dnew[inan,:] #Select only sea points
dnew = signal.detrend(dnew,1) #detrend
#Compute covariance-like matrix (not scaled!)
dd = np.matmul(dnew.T,dnew)
# Extract eigenvectors and eigenvalues
[lambdas,A] = np.linalg.eig(dd)

E = np.matmul(dnew,A)#Project data onto eigenvectors
varexp_detrend_mano = 100*lambdas/lambdas.sum() #Compute explained variance

# renormalize to obtain PCs in STD units and EOFs in regression units [°C/std]
nmodes = T
for i in range(T):
 m1 = np.empty((I*J))*np.nan
 m1[inan] = E[:,i]
 mstd = np.std(A[:,i])
 eofs_detrend_mano[:,:,i] = m1.reshape(I,J).T*mstd
 pcs_detrend_mano[:,i] = A[:,i]/mstd

fig = plt.figure(figsize=(18,6))
gs = fig.add_gridspec(3, 2)

for i in range(3):
  # Select the week 1 forecast from the specified model
  data = eofs_detrend_mano[:,:,i]
  # Add the cyclic point
  data,lons = add_cyclic_point(data,coord=ds_mano['lon'])
  ax1 = fig.add_subplot(gs[i, 0], projection=ccrs.PlateCarree())
  cs = ax1.pcolor(lons,ds_mano['lat'],data,vmin=-0.4,vmax=0.4,
                    transform = ccrs.PlateCarree(),
                    cmap='coolwarm')

  ax1.coastlines(resolution='auto', color='k')
  ax1.set_title('EOF'+str(i+1)+' [°C/std]')
  # ax1.gridlines(color='lightgrey', linestyle='-', draw_labels=True)

  ax2 = fig.add_subplot(gs[i, 1])
  ax2.plot(ds['time'],pcs_detrend_mano[:,i])
  ax2.set_ylabel('PC'+str(i+1)+' [Norm.]')
  ax2.set_xlabel('time')

# Adjust the location of the subplots on the page to make room for the colorbar
fig.subplots_adjust(bottom=0.2, top=0.9, left=0.125, right=0.9,
                    wspace=0.02, hspace=0.25)
# Add a colorbar axis at the bottom of the graph
cbar_ax = fig.add_axes([0.2, 0.1, 0.25, 0.02])
# Draw the colorbar
cbar = fig.colorbar(cs, cax=cbar_ax,orientation='horizontal')

for i in range(3):
  print('Percentage of variance explained by mode ' + str(i+1)+ ': ' +
        str(varexp_detrend_mano[i]))

"""OBSERVATIONS: using the detrended anomaly, the first mode becomes El Nino.\\
The second mode is a small oscillation and low frequency phenomenon, it could be PDO, and has a really weak correlations. \\
The third phenomenon is coastal El Nino, and has a weak correlation as well.

##  Eigenvalue spectrum
"""

fig, ax = plt.subplots(nrows=1, ncols=1,figsize=(20, 10))

ax.plot(varexp_mano[:20])
ax.title.set_text('Eigenvalues spectrum')
plt.grid()

"""This is the percentage of the variances of the first 20 EOFs. The percentages decrease as we go higher in order with the EOFs, so that the first EOF will show the strongest correlation, the second EOF will show the second strongest correlation and so on. In general we should take into consideration the first fews EOF, since the higher values EOFs will show some noise and hence lose physical meaning. And in fact, the explained variance decreases drastically after the first two modes.

##  EOF reconstruction
"""

# Reconstruct the SSTa using only 3 components
eofs1d = eofs_mano.reshape((I*J,T))
SSTa1d_rec_N3 = np.matmul(eofs1d[:,:3],pcs_mano[:,:3].T)
SSTa1d_rec_N7 = np.matmul(eofs1d[:,:7],pcs_mano[:,:7].T)

SSTa_rec_N3 = SSTa1d_rec_N3.reshape((J,I,T))
SSTa_rec_N7 = SSTa1d_rec_N7.reshape((J,I,T))

fig = plt.figure(figsize=(18,6))
gs = fig.add_gridspec(1, 3)

data = ds_std_mano.sst[:,:]
# Add the cyclic point
data,lons = add_cyclic_point(data,coord=ds_mano['lon'])
ax1 = fig.add_subplot(gs[0, 0], projection=ccrs.PlateCarree())
cs = ax1.contourf(lons,ds_mano['lat'],data,
                  transform = ccrs.PlateCarree(),
                  cmap='coolwarm',extend='both')
ax1.coastlines(resolution='auto', color='k')
ax1.set_title('SSTa'+'[°C]')

data3 = SSTa_rec_N3[:,:,479]
# Add the cyclic point
data3,lons=add_cyclic_point(data3,coord=ds_mano['lon'])
ax1 = fig.add_subplot(gs[0, 1], projection=ccrs.PlateCarree())
cs = ax1.contourf(lons,ds_mano['lat'],data3,
                  transform = ccrs.PlateCarree(),
                  cmap='coolwarm',extend='both')
ax1.coastlines(resolution='auto', color='k')
ax1.set_title('SSTa_rec N3'+'[°C]')

data7 = SSTa_rec_N7[:,:,479]
# Add the cyclic point
data7,lons = add_cyclic_point(data7,coord=ds_mano['lon'])
ax1 = fig.add_subplot(gs[0, 2], projection=ccrs.PlateCarree())
cs = ax1.contourf(lons,ds_mano['lat'],data7,
                  transform = ccrs.PlateCarree(),
                  cmap='coolwarm',extend='both')
ax1.coastlines(resolution='auto', color='k')
ax1.set_title('SSTa_rec N7'+'[°C]')

# Adjust the location of the subplots on the page to make room for the colorbar
fig.subplots_adjust(bottom=0.2, top=0.9, left=0.125, right=0.9,
                    wspace=0.02, hspace=0.25)
# Add a colorbar axis at the bottom of the graph
cbar_ax = fig.add_axes([0.2, 0.3, 0.6, 0.02])
# Draw the colorbar
cbar = fig.colorbar(cs, cax=cbar_ax,orientation='horizontal')

fig,ax = plt.subplots(nrows=3, ncols=1, sharex=True,figsize=(15,6),
                      constrained_layout = True)

# Plot the time series observed SST anomalies for EEP
y = ds_mano.sel(lon=-110,lat=0,method='nearest').sst
ax[0].plot(ds.time,y, color='r')
ax[0].set(xlabel="time",ylabel="Temperature [°C]",title="Observed SST anomalies in EEP")

#SST anomaly reconstructed for EEP - first 3 EOFs
data_EEP = ds_mano.sel(lon=-110,lat=0,method='nearest').sst.values
EEP_J = np.where(ds.lat == ds.sst.sel(lon=-110, lat=0, method='nearest').lat)[0][0]
EEP_I = np.where(ds.lon == ds.sst.sel(lon=-110,lat=0, method='nearest').lon)[0][0]
eofs_mano_1d = eofs_mano.reshape((I*J,T))
SSTa1d_rec_3 = np.matmul(eofs_mano_1d[:,:3], pcs_mano[:,:3].T)
SSTa_rec_3 = SSTa1d_rec_3.reshape((J,I,T))
y3 = SSTa_rec_3[EEP_J,EEP_I,:]

ax[1].plot(ds.time,y3, color='r')
ax[1].set_title('SST anomaly in EEP reconstructed with the first 3 EOFs')

#SST anomaly reconstructed for EEP - first 7 EOFs
eofs_mano_1d = eofs_mano.reshape((I*J,T))
SSTa1d_rec_7 = np.matmul(eofs_mano_1d[:,:7], pcs_mano[:,:7].T)
SSTa_rec_7 = SSTa1d_rec_7.reshape((J,I,T))
y7 = SSTa_rec_7[EEP_J,EEP_I,:]

ax[2].plot(ds.time,y7, color='r')
ax[2].set_title('SST anomaly in EEP reconstructed with the first 7 EOFs')

print('Correlation coefficient between the observed data and the data reconstructed with 3 EOFs for EEP: '+ str(np.corrcoef(y,y3)[1,0]))
print('Correlation coefficient between the observed data and the data reconstructed with 7 EOFs for EEP: '+ str(np.corrcoef(y,y7)[1,0]))

"""OBSERVATIONS: the Equatorial East Pacific seems to be generally well reproduced by the EOFs. In fact the reconstruction with 7 EOFs correlates by almost 95%. This could be due to the fact that the main source for anomalies in this area is due to El Nino, which is also the first EOF pattern of the global monthly mean anomaly, hence the mode with the strongest correlation."""

fig,ax = plt.subplots(nrows=3, ncols=1, sharex=True,figsize=(15,6),
                      constrained_layout = True)

# Plot the time series observed SST anomalies for NEP
y = ds_mano.sel(lon=-145,lat=50,method='nearest').sst
ax[0].plot(ds.time,y, color='r')
ax[0].set(xlabel="time",ylabel="Temperature [°C]",
          title="Observed SST anomalies in NEP")

#SST anomaly reconstructed for NEP - first 3 EOFs
data_NEP = ds_mano.sel(lon=-145,lat=50,method='nearest').sst.values

NP_J = np.where(ds.lat == ds.sst.sel(lon=-145,lat=50,method='nearest').lat)[0][0]
NP_I = np.where(ds.lon == ds.sst.sel(lon=-145,lat=50,method='nearest').lon)[0][0]
eofs_mano_1d = eofs_mano.reshape((I*J,T))
SSTa1d_rec_3 = np.matmul(eofs_mano_1d[:,:3], pcs_mano[:,:3].T)
SSTa_rec_3 = SSTa1d_rec_3.reshape((J,I,T))
y3 = SSTa_rec_3[NP_J,NP_I,:]

ax[1].plot(ds.time,y3, color='r')
ax[1].set_title('SST anomaly in NEP reconstructed with the first 3 EOFs')

#SST anomaly reconstructed for NEP - first 7 EOFs

eofs_mano_1d = eofs_mano.reshape((I*J,T))
SSTa1d_rec_7 = np.matmul(eofs_mano_1d[:,:7], pcs_mano[:,:7].T)
SSTa_rec_7 = SSTa1d_rec_7.reshape((J,I,T))
y7 = SSTa_rec_7[NP_J,NP_I,:]

ax[2].plot(ds.time,y7, color='r')
ax[2].set_title('SST anomaly in NEP reconstructed with the first 7 EOFs')

print('Correlation coefficient between the observed data and the data reconstructed with 3 EOFs for NEP: '+ str(np.corrcoef(y,y3)[1,0]))
print('Correlation coefficient between the observed data and the data reconstructed with 7 EOFs for NEP: '+ str(np.corrcoef(y,y7)[1,0]))

"""OBSERVATIONS: this area is generally not as well reproduced by the EOFs. In fact the EOF that correlates the most has a percentae of 71%. This could be due to the fact that, as I previously said, the first EOF for the monthly mean anomalies is El Nino, but in this case the main source of anomalies for the area of the North Pacific is not El Nino.

## Image compression using EOF
"""

# import the image as an array
img_array = plt.imread(datadir+'/Tech_TowerAndShop_1899.gif')
print('Image size: '+str(img_array.shape))
#You can display the image using imshow from plt:
plt.imshow(img_array,cmap='gray')

#% (1) Compute IMG anomalies (IMGa) (i.e., each column of IMGa has 0 mean)
img_array = img_array.astype(float)
IMGa = np.empty(shape=(331,565))
for i in range(len(img_array[1])):
  IMGa[:,i] = img_array[:,i] - np.mean(img_array[:,i])

plt.imshow(IMGa, cmap='gray')

#% (2) Use the IMGa to compute the EOF decomposition (find EOFs/PCs)
#Prepare empty arrays
I,T = IMGa.shape #Get dataset dimensions
eofs = np.empty((I,T))
pcs = np.empty((T,T))
dnew = IMGa
#Compute covariance-like matrix (not scaled!)
dd = np.matmul(dnew.T,dnew)
# Extract eigenvectors and eigenvalues
[lambdas,A] = np.linalg.eig(dd)

E = np.matmul(dnew,A)#Project data onto eigenvectors
varexp = 100*lambdas/lambdas.sum() #Compute explained variance

# renormalize to obtain PCs in STD units and EOFs in regression units [°C/std]
nmodes = T
for i in range(T):
 m1 = E[:,i]
 mstd = np.std(A[:,i])
 eofs[:,i] = m1.T*mstd
 pcs[:,i] = A[:,i]/mstd

#% (3) Reconstruct the anomalies using an EOF/PC subset
# Reconstruct keeping 20%
new_size = img_array.shape[0]*img_array.shape[1]*0.2
new_mode = new_size/(img_array.shape[0]+img_array.shape[1])
new_mode = int(new_mode)
IMGa1d_rec = np.matmul(eofs[:,:new_mode],pcs[:,:new_mode].T)

IMGa1d_rec_20 = np.empty_like(IMGa)
for i in range(T):
  IMGa1d_rec_20[:,i] = IMGa1d_rec[:,i] + np.mean(img_array[:,i])

#% (4) Recover the picture adding to the anomalies reconstructed in (3)
fig = plt.figure()
ax = fig.add_subplot(1,1,1)
ax.imshow(IMGa1d_rec_20,cmap='gray')

i=0
variance=0
while i<42:
  variance += varexp[i]
  i += 1

ax.set_title('Image reconstructed and reduced at 20% using '+str(new_mode)+' EOFs')
print('The percentage of variance explainde by the '+str(new_mode)+' mode is '+ str(variance))